use std::{
    fmt::{Debug, Display},
    hash::Hash,
    marker::PhantomData,
};

/// An opaque reference to a value in an [SlotArena](crate::SlotArena), represented as a [u32]
/// index.
pub struct Ref<T> {
    marker: PhantomData<T>,
    idx: u32,
}

impl<T> Ref<T> {
    /// Creates a [Ref] from a raw index value.  Should not be used directly, [Ref]s should be
    /// generated by [SlotArena](crate::SlotArena)s only.
    #[inline]
    pub const fn from_raw(idx: u32) -> Self {
        Self {
            marker: PhantomData,
            idx,
        }
    }

    /// Returns the raw index of the [Ref] value.
    #[inline]
    pub const fn to_raw(self) -> u32 {
        self.idx
    }
}

impl<T> Clone for Ref<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self {
            marker: PhantomData,
            idx: self.idx,
        }
    }
}

impl<T> Copy for Ref<T> {}

impl<T> Debug for Ref<T> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "Ref::<{}>({})", std::any::type_name::<T>(), self.idx)
    }
}

impl<T> Display for Ref<T> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "Ref::<{}>({})", std::any::type_name::<T>(), self.idx)
    }
}

impl<T> Hash for Ref<T> {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        state.write_u32(self.idx);
    }
}

impl<T> PartialEq for Ref<T> {
    fn eq(&self, other: &Self) -> bool {
        self.idx == other.idx
    }
}

impl<T> Eq for Ref<T> {}

impl<T> PartialOrd for Ref<T> {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        self.idx.partial_cmp(&other.idx)
    }
}

impl<T> Ord for Ref<T> {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.idx.cmp(&other.idx)
    }
}
